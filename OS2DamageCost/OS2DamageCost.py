# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FloodDamageCost
                                 A QGIS plugin
 Plugin to model economic consequences of climate changes
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-23
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Bo Victor Thomsen - AestasGIS Denmark
        email                : bvt@aestas.dk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import sys
import re
import tempfile
import pandas as pd
import numpy as np

from functools import partial


from qgis.PyQt.QtCore import (QSettings,
                              QTranslator,
                              QCoreApplication,
                              qVersion,
                              Qt,
                              QVariant,
                              QUrl,
                              QDate,
                              QTime,
                              QDateTime
                              )
                          
from qgis.PyQt.QtGui import QIcon

from qgis.PyQt.QtWidgets import (QDialog,
                                 QFileDialog,
                                 QAction,
                                 QMenu,
                                 QWidget,
                                 QTreeView,
                                 QAbstractItemView,
                                 QDialogButtonBox,
                                 QLineEdit,
                                 QTextEdit,
                                 QSpinBox,
                                 QDoubleSpinBox,
                                 QCheckBox,
                                 QComboBox,
                                 QDateTimeEdit,
                                 QDateEdit,
                                 QTimeEdit,
                                 QLayout,
                                 QHeaderView,
                                 QVBoxLayout,
                                 QHBoxLayout,
                                 QLabel)

from qgis.PyQt.Qt import (QStandardItemModel,
                          QStandardItem)

from qgis.PyQt.QtSql import (QSqlDatabase, QSqlQuery)
                          
from qgis.core import (QgsProject,
                       QgsProviderRegistry,
                       QgsDataSourceUri,
                       QgsExpressionContextUtils,
                       QgsVectorLayer,
                       QgsVectorLayerUtils,
                       QgsAbstractDatabaseProviderConnection,
                       QgsAuthMethodConfig,
                       QgsMapLayer,
                       QgsWkbTypes,
                       QgsApplication)

from qgis.gui import QgsFileWidget, QgsCheckableComboBox

from .resources import *

from .helper import (#tr,
                     trInit,
                     logI,
                     logW,
                     logC,
                     messI,
                     messW,
                     messC,
                     read_config,
                     write_config,
                     handleRequest,
                     mapperExtent,
                     createDateTimeName,
                     loadLayer,
                     createGroup,
                     addLayer2Tree,
                     createMemLayer,
                     createRequestLog,
                     copyLayer2Layer,
                     findLayerVariableValue,
                     evalLayerVariable,
                     zoomToFeature,
                     isInt,
                     isFloat,
                     mapperExtent,
                     findLayerVariableList,
                     merge_layers_in_group,
                     populateLayerTreeCB,
                     AssignSubAreas,                     
                     executeSQL)

from .OS2DamageCost_dockwidget import FloodDamageCostDockWidget

import os.path
import time

PARM_NO_COLUMNS = 10 

class FloodDamageCost:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'OS2DamageCost_{}.qm'.format(locale))
        logI(locale_path)
        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            
            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        trInit('FloodDamageCost')


        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&OS2 Flood Damage Cost')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'FloodDamageCost')
        self.toolbar.setObjectName(u'FloodDamageCost')

        #print "** INITIALIZING FloodDamageCost"

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('FloodDamageCost', message)
    
    
    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/OS2DamageCost/skadesokonomi.png'
#        icon_path = ':/plugins/OS2DamageCost/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Open OS2 Flood Damage Cost'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING FloodDamageCost"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD FloodDamageCost"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&OS2 Flood Damage Cost'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            if self.dockwidget == None:

                self.dockwidget = FloodDamageCostDockWidget()

                #self.model = QStandardItemModel()
                #self.model.setHorizontalHeaderLabels(['Name', 'Height', 'Weight'])
                self.parm = read_config(os.path.join(self.plugin_dir, 'configuration.json'))

                sd = self.dockwidget
                spd = self.parm["Data"]

                sd.pbDatabase.clicked.connect(self.pbDatabaseClicked)
                sd.pbParameterSave.clicked.connect(self.pbParameterSaveClicked)
                sd.pbParameterReset.clicked.connect(self.pbParameterResetClicked)
                sd.pbParameterShow.clicked.connect(self.pbParameterShowClicked)
                sd.pbModelRun.clicked.connect(self.pbModelRunClicked)
                sd.pbMapperExtents.clicked.connect(self.pbMapperExtentsClicked)
                sd.pbCreateCellLayer.clicked.connect(self.pbCreateCellLayerClicked)
                sd.pbUpdCellLayer.clicked.connect(self.pbUpdCellLayerClicked)
                sd.pbClearValues.clicked.connect(self.pbClearValuesClicked)
                sd.pbUpdateLayerTree.clicked.connect(self.pbUpdateLayerTreeClicked)
                sd.pbDamage.clicked.connect(self.pbDamageClicked)
                sd.pbValue.clicked.connect(self.pbValueClicked)
                sd.pbRisk.clicked.connect(self.pbRiskClicked)
                sd.pbClearAll.clicked.connect(self.pbClearAllClicked)
                sd.pbCellExtract.clicked.connect(self.pbCellExtractClicked)
                sd.pbAdministration.clicked.connect(self.pbAdministrationClicked)
                sd.cbDatabase.currentIndexChanged.connect(self.cbDatabaseCurrentIndexChanged)
                sd.pbHistFilterSearch.clicked.connect(self.pbHistFilterSearchClicked)
                sd.pbHistResetSearch.clicked.connect(self.pbHistResetSearchClicked)
                sd.cbHistFields.currentIndexChanged.connect(self.cbHistFieldsCurrentIndexChanged)
                sd.cbHistOperators.currentIndexChanged.connect(self.cbHistOperatorsCurrentIndexChanged)
                sd.twFloodDamageCost.currentChanged.connect (self.twFloodDamageCostCurrentChanged)
                sd.cbAreaLayer.currentIndexChanged.connect(self.cbAreaLayerCurrentIndexChanged)

                hist_fields = [".. choose field", "batch_name ", "run_at ", "no_models ", "table_name ", "model_name ", "no_rows ", " no_secs ", "parameter_name " , "value "]
                sd.cbHistFields.addItems(hist_fields)
                
                hist_operators = [".. choose operator", "LIKE ", "ILIKE ", "'%..%' ", "< ", "<= ", "= ", "> ", ">= ", "<> ", "AND ", "OR ", "NOT ", "( ", ") "]
                sd.cbHistOperators.addItems(hist_operators)


                for tv in [sd.tvGeneral, sd.tvQueries, sd.tvData, sd.tvModels, sd.tvHistory]: #, sd.tvReports]:
                    tv.setEditTriggers(QAbstractItemView.NoEditTriggers)
                    tv.setSelectionBehavior(QAbstractItemView.SelectRows)
                    tv.setSelectionMode(QAbstractItemView.SingleSelection)

                sd.tvGeneral.doubleClicked.connect(self.tvGeneralDoubleClicked)
                sd.tvQueries.doubleClicked.connect(self.tvQueriesDoubleClicked)
                sd.tvData.doubleClicked.connect(self.tvDataDoubleClicked)
                sd.tvModels.doubleClicked.connect(self.tvModelsDoubleClicked)
                #sd.tvReports.doubleClicked.connect(self.tvReportsDoubleClicked)
                sd.tvHistory.setContextMenuPolicy(Qt.CustomContextMenu)
                sd.tvHistory.customContextMenuRequested.connect(self.openHistMenu)

                sd.pbCSVExportDir.clicked.connect(self.pbCSVExportDirClicked)
                sd.pbCSVExport.clicked.connect(self.pbCSVExportClicked)
                sd.leCSVExportDir.setText(tempfile.gettempdir().rstrip(os.path.sep))
                
                sd.pbAreaSub.clicked.connect(self.pbAreaSubClicked)
                

                self.pbDatabaseClicked()
                self.pbParameterResetClicked()
                self.pbUpdCellLayerClicked()
                self.pbAdministrationClicked()     
                self.twFloodDamageCostCurrentChanged (6)                

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()


    def twFloodDamageCostCurrentChanged (self, index):
    
        sd = self.dockwidget        
        if index == 6:
            populateLayerTreeCB (sd.cbAreaLayer, QgsMapLayer.VectorLayer, QgsWkbTypes.PolygonGeometry)
    
    def pbAreaSubClicked(self):

        sd = self.dockwidget        
        group_name = self.treeViewItemText(sd.tvGeneral,'Model_layergroup',2)
        subLayer = sd.cbAreaLayer.currentText()
        subColumn = sd.cbAreaColumn.currentText()
        #messI(subLayer + ' ' + subColumn)
        antl, anto = AssignSubAreas(group_name, 'omraade', ' ', subLayer, subColumn)
        
        messI (self.tr (f'No layers processed: {antl}, Total no. of objects processed: {anto}'))  
        
        
    def cbAreaLayerCurrentIndexChanged(self, index):

        sd = self.dockwidget    
        root = QgsProject.instance().layerTreeRoot()

        layerTreeId = sd.cbAreaLayer.currentData()
        layerTree = root.findLayer(layerTreeId)  
        if layerTree: 
            layer = root.findLayer(layerTreeId).layer()
            sd.cbAreaColumn.clear()
            for c in layer.fields(): sd.cbAreaColumn.addItem (c.name(),c)
        
    
    def openHistMenu(self, position):
    
        sd = self.dockwidget        
        indexes = sd.tvHistory.selectedIndexes()

        if len(indexes) > 0:
       
            level = 0
            index = indexes[0]
            while index.parent().isValid():
                index = index.parent()
                level += 1
        
            menu = QMenu()
            if level == 0:
                action_batches_remove = menu.addAction(self.tr("Remove batch entry and result tables"))
                action_batches_remove.triggered.connect(lambda: messI(self.tr('Function not implemented (yet)')) )
                action_batches_rerun = menu.addAction(self.tr("Run batch set of models"))
                action_batches_rerun.triggered.connect(lambda: messI(self.tr('Function not implemented (yet)')) )
            elif level == 1:
                action_models_remove = menu.addAction(self.tr("Remove model entry and result table"))
                action_models_remove.triggered.connect(lambda: messI(self.tr('Function not implemented (yet)')) )
                action_models_rerun = menu.addAction(self.tr("Run model with possibly changed parameters"))
                action_models_rerun.triggered.connect(lambda: messI(self.tr('Function not implemented (yet)')) )
            elif level == 2:
                action_parameters_edit = menu.addAction(self.tr("Edit parameter value"))
                action_parameters_edit.triggered.connect(lambda: messI(self.tr('Function not implemented (yet)')) )
#                action_parameters_edit.triggered.connect(partial(self.not_implemented, 2, 3))
        
            menu.exec_(sd.tvHistory.viewport().mapToGlobal(position))

    def not_implemented(self, level, mdlIdx):

        logI(self.tr('Function not implemented (yet)'))


    def cbHistFieldsCurrentIndexChanged (self, index):

        sd = self.dockwidget        
        if index != 0:
            sd.leHistFilter.setText(sd.leHistFilter.text() + sd.cbHistFields.currentText())  
            sd.cbHistFields.setCurrentIndex(0)

    def cbHistOperatorsCurrentIndexChanged (self, index):
        sd = self.dockwidget        
        if index != 0:
            sd.leHistFilter.setText(sd.leHistFilter.text() + sd.cbHistOperators.currentText())  
            sd.cbHistOperators.setCurrentIndex(0)

    def pbHistFilterSearchClicked(self):

        sd = self.dockwidget
        txt = sd.leHistFilter.text().strip()
        if txt != '':  
            self.loadHistTree(sd.tvHistory, self.connection,txt)
        else:
            messC(self.tr('History filter is empty!'))       

    def pbHistResetSearchClicked(self): 

        sd = self.dockwidget
        sd.leHistFilter.setText('')
        self.loadHistTree(sd.tvHistory, self.connection,sd.leHistFilter.text())

    def pbAdministrationClicked(self):
    
        sd = self.dockwidget
        
        vis = (sd.twFloodDamageCost.isTabVisible(0) == False)
        
        sd.twFloodDamageCost.setTabVisible(0,vis)
        sd.twFloodDamageCost.setTabVisible(1,vis)
        sd.twFloodDamageCost.setTabVisible(2,vis)

    def pbDatabaseClicked(self):

        sd = self.dockwidget
        spd = self.parm["Data"]

        sd.cbDatabase.clear()

# Kun postgres forbindelser...       for k in QgsProviderRegistry.instance().providerList():

        k = 'postgres'
        metadata = QgsProviderRegistry.instance().providerMetadata(k)

        try:
            conn = metadata.connections(False)
            for c,i in conn.items(): sd.cbDatabase.addItem('{}: {}'.format(k, c), [k, c])

        except Exception as e:
            logC(self.tr('Error using connection type: {}').format(k))
                
        sd.cbDatabase.setCurrentIndex(sd.cbDatabase.findText(spd['Database']))
        sd.leParameterTable.setText(spd['Parametertable'])        
        #sd.leParameterSQL.setText(spd['ParameterSQL'])        
        #sd.chbParameter.setChecked(spd['Load as layer'])        
        
    def pbMapperExtentsClicked(self):

        sd = self.dockwidget
        extent = self.iface.mapCanvas().extent()

        sd.dsbXMin.setValue(extent.xMinimum())
        sd.dsbXMax.setValue(extent.xMaximum())
        sd.dsbYMin.setValue(extent.yMinimum())
        sd.dsbYMax.setValue(extent.yMaximum())



    def pbUpdCellLayerClicked(self):

        sd = self.dockwidget

        vlist = findLayerVariableList ('eco_celllayer')
        sd.cbCellLayer.clear()
        root = QgsProject.instance().layerTreeRoot()
        for v in vlist:
            ltl = root.findLayer(v)
            sd.cbCellLayer.addItem(ltl.name(),ltl)
        
       
        
    def pbCreateCellLayerClicked(self):

        sd = self.dockwidget

        #createCellTemplate = self.parmDict['Create cell layer template']['value']
        createCellTemplate = self.treeViewItemText(sd.tvGeneral,'Create cell layer template',2)
        clayer = sd.leLayerName.text()

        rschema = ''
        if clayer.find('.') < 0: # tablename without schema definition 
            rschema = self.treeViewItemText(sd.tvGeneral,'Result_schema',2)

        if clayer and createCellTemplate and rschema:
            clayer = clayer if rschema == '' else rschema + '.' + clayer
            sqlCmd = createCellTemplate.format(
                celltable=clayer,
                epsg=self.iface.mapCanvas().mapSettings().destinationCrs().authid().replace('EPSG:',''),
                xmin=sd.dsbXMin.value(),
                xmax=sd.dsbXMax.value(),
                ymin=sd.dsbYMin.value(),
                ymax=sd.dsbYMax.value(),
                cellsize=sd.dsbCellSize.value()
            )
    
    #        query = QSqlQuery()
    #        query.exec(sqlCmd)    
    #
    #        error = query.lastError().text()
    #        if error != '':
    #            messC(error)                
    #
    #
    #        else: 
            query = executeSQL(sqlCmd)
            if query:
                uri = self.conuri
                sandt = clayer.split('.',1)
                uri.setDataSource (sandt[0], sandt[1], 'geom')
                layer = QgsVectorLayer(uri.uri(), clayer, self.contype)
                ltl = addLayer2Tree(QgsProject.instance().layerTreeRoot(), layer, True, 'eco_celllayer', clayer, os.path.join(self.plugin_dir, 'styles', 'cells.qml'), clayer)
                sd.cbCellLayer.addItem(layer.name(), ltl)
                sd.cbCellLayer.setCurrentIndex(sd.cbCellLayer.count()-1)
            
    def pbClearValuesClicked(self):

        sd = self.dockwidget
        ltl = sd.cbCellLayer.currentData()
        clearTemplate = self.parmDict['Clear cell layer template']['value']
        uri = ltl.layer().dataProvider().uri()
        sqlCmd = clearTemplate.format(schema = uri.schema(), table = uri.table())
#        query = QSqlQuery()
#        query.exec(sqlCmd)    
        query = executeSQL(sqlCmd)
        if query:
            ltl.layer().triggerRepaint()
            ltl.layer().reload()
            self.iface.mapCanvas().refresh()

    def pbUpdateLayerTreeClicked(self):

        sd = self.dockwidget

        modC = QStandardItemModel()
        modC.setRowCount(0)
        rootC = modC.invisibleRootItem()
        modC.setHorizontalHeaderLabels(['Navn','Gruppe/Beløbstype','Uri'])

        ltRoot = QgsProject.instance().layerTreeRoot()
        tvqmRoot = sd.tvQueries.model().invisibleRootItem().child(0,0)
        idList = findLayerVariableList('eco_resultlayer')

        # Enumerate list
        for id in idList:
            ltl = ltRoot.findLayer(id)        
            qsi = QStandardItem(ltl.name())

            qname = QgsExpressionContextUtils.layerScope(ltl.layer()).variable('eco_resultlayer') 

            uri = ltl.layer().dataProvider().uri()
            tabledef = uri.quotedTablename() 
            # Find query item
            for item in self.iterItemsMatch(tvqmRoot, qname): 
                # Find field item thats checkable
                for jtem in self.iterRowCheckable(item): 
                    qsisub = QStandardItem(jtem[2].text())
                    qsisub.setFlags(qsisub.flags() | Qt.ItemIsUserCheckable)
                    qsisub.setCheckState(Qt.Unchecked)
                    vtype = 'Skadesomkostninger' if jtem[0].text()[:6]=='f_dama' else 'Værditab' if jtem[0].text()[:6]=='f_loss' else 'Risiko' 
                    qsi.appendRow([qsisub,QStandardItem(vtype),QStandardItem(id)])  
            
            if qsi.hasChildren(): 
                rootC.appendRow([qsi, QStandardItem(ltl.parent().name()), QStandardItem('')])
            
            
            #if qsi.hasChildren(): rootC.appendRow([qsi, QStandardItem(ltl.parent().name())])

        sd.tvCells.setModel(modC)
        sd.tvCells.hideColumn(2)
        sd.tvCells.header().setStretchLastSection(True);
        sd.tvCells.header().setSectionResizeMode(QHeaderView.ResizeToContents)
        sd.tvCells.setAlternatingRowColors(True)        
        sd.tvCells.expandAll()

    def pbDamageClicked(self):

        sd = self.dockwidget
        self.setCheckModel(sd.tvCells.model().invisibleRootItem(),'Skadesomkostninger',1,Qt.Checked)
    
    def pbValueClicked(self):

        sd = self.dockwidget
        self.setCheckModel(sd.tvCells.model().invisibleRootItem(),'Værditab',1,Qt.Checked)
    
    def pbRiskClicked(self):

        sd = self.dockwidget
        self.setCheckModel(sd.tvCells.model().invisibleRootItem(),'Risiko',1,Qt.Checked)
    
    def pbClearAllClicked(self):

        sd = self.dockwidget
        self.setCheckModel(sd.tvCells.model().invisibleRootItem(),'Risiko',1,Qt.Unchecked)
        self.setCheckModel(sd.tvCells.model().invisibleRootItem(),'Værditab',1,Qt.Unchecked)
        self.setCheckModel(sd.tvCells.model().invisibleRootItem(),'Skadesomkostninger',1,Qt.Unchecked)
    
    def setCheckModel(self,root,txt,col,value=Qt.Unchecked):
        if root is not None:
            stack = [root]
            while stack:
                parent = stack.pop(0)
                for row in range(parent.rowCount()):
                    child = parent.child(row, 0)
                    child2 = parent.child(row, col)
                    if child.isCheckable() and child2.text() == txt: child.setCheckState(value)
                    if child.hasChildren(): stack.append(child)
     
    def pbCellExtractClicked(self):
        
        sd = self.dockwidget
        
        # Update template information
        for item in self.iterItemsMatch(sd.tvGeneral.model().invisibleRootItem(), 'update cell layer'): 
            parent = item.parent()
            updTemplate = parent.child(item.row(),2).text()

        # Cell table information
        cLtl = sd.cbCellLayer.currentData()
        cUri = cLtl.layer().dataProvider().uri()
        cell_table = cUri.quotedTablename() 
        geom_cell = cUri.geometryColumn()        
        pci = cLtl.layer().dataProvider().pkAttributeIndexes()[0]
        pkey_cell = cLtl.layer().dataProvider().fields()[pci].name()

        query = QSqlQuery()
        ltRoot = QgsProject.instance().layerTreeRoot()
        for item in self.iterItemsChecked(sd.tvCells.model().invisibleRootItem()):
            # Value table information
            parent = item.parent()
            layerId = parent.child(item.row(),2).text()
            
            vLtl = ltRoot.findLayer(layerId)        
            vUri = vLtl.layer().dataProvider().uri()
            value_table = vUri.quotedTablename() 
            geom_value = vUri.geometryColumn()        
            value_value = item.text()
            updCmd = updTemplate.format(cell_table=cell_table, pkey_cell=pkey_cell, geom_cell=geom_cell, value_table=value_table, geom_value=geom_value, value_value=value_value)
            query = executeSQL(updCmd)
 
        cLtl.layer().triggerRepaint()
        cLtl.layer().reload()
        self.iface.mapCanvas().refresh()

        #QgsProject.instance().reloadAllLayers()    


    def pbParameterSaveClicked(self):

        deleteTemplate = 'DELETE FROM {}'
        insertTemplate = 'INSERT INTO {} ({}) VALUES ({});'

        sd = self.dockwidget
        spd = self.parm["Data"]

        parametertable = sd.leParameterTable.text()

        columnNames =  [sd.tvGeneral.model().headerData(i,Qt.Horizontal) for i in range(sd.tvGeneral.model().columnCount())]
        colnames = '", "'.join(columnNames)
        colnames= '"' + colnames + '"'

        placeList =  [' ?' for i in range(sd.tvGeneral.model().columnCount())]
        placeholders = ','.join(placeList)

        query = executeSQL(deleteTemplate.format(parametertable))

        insertCmd = insertTemplate.format(parametertable, colnames, placeholders)
        insertDataQuery = QSqlQuery()
        insertDataQuery.prepare(insertCmd)
        for tv in [sd.tvGeneral, sd.tvQueries, sd.tvData, sd.tvModels]: #, sd.tvReports]:
            for row in self.iterRowItems(tv.model().invisibleRootItem()): 
                if row[0] == 'Group name template': row[2] = sd.leGroupName.text()
                for i in range(len(row)): insertDataQuery.addBindValue(row[i])
                insertDataQuery.exec()
                if insertDataQuery.lastError().text() != '': logC(insertDataQuery.lastError().text())                
              
        
    def iterRowItems(self, root):
        if root is not None:
            stack = [root]
            while stack:
                parent = stack.pop(0)
                for row in range(parent.rowCount()):
                    rowval = []
                    for column in range(parent.columnCount()): rowval.append(parent.child(row, column).text())
                    yield rowval
                    child0 = parent.child(row, 0)
                    if child0.hasChildren(): stack.append(child0)

    def dbConnection2Db (self, dbType, connectionName):

        metadata = QgsProviderRegistry.instance().providerMetadata(dbType)
        self.connection = metadata.findConnection(connectionName)
        uri = QgsDataSourceUri(self.connection.uri())

        cnvDict = {'ogr':'QSPATIALITE','spatialite':'QSPATIALITE','postgres':'QPSQL','mssql':'QODBC'} # , 'oracle':'QOCI', 'sqlite':'QSQLITE'}

        if dbType in cnvDict:
        
            dbQtType = cnvDict[dbType]            
            db = QSqlDatabase.addDatabase(dbQtType);

            if dbQtType ==  'QPSQL':

                db.setHostName(uri.host())
                db.setDatabaseName(uri.database())
                db.setPort(int(uri.port()))
                myname, mypass = self.get_postgres_conn_info(connectionName)
                db.setUserName(myname)
                db.setPassword(mypass)

            elif dbQtType ==  'QODBC':

                db.setDatabaseName(uri.uri());

            elif dbQtType ==  'QSPATIALITE':

                db.setDatabaseName(uri.uri())    

            if not db.open():
                logC('dbConnection2Db: Open error: {}'.format(db.lastError().databaseText()))
                messC('Database open error: {}'.format(db.lastError().databaseText()))

        else:
 
            logC('dbConnection2Db: Unknown databasetype: {}'.format(dbType))
            return None, None

        return uri    

    def get_postgres_conn_info(self, selected):
        """ Read PostgreSQL connection details from QSettings stored by QGIS
        """
        settings = QSettings()
        settings.beginGroup(u"/PostgreSQL/connections/" + selected)
        if not settings.contains("database"): # non-existent entry?
            return {}
    
        conn_info = dict()
        conn_info["host"] = settings.value("host", "", type=str)
    
        # password and username
        username = ''
        password = ''
        authconf = settings.value('authcfg', '')
        if authconf :
            # password encrypted in AuthManager
            auth_manager = QgsApplication.authManager()
            conf = QgsAuthMethodConfig()
            auth_manager.loadAuthenticationConfig(authconf, conf, True)
            if conf.id():
                username = conf.config('username', '')
                password = conf.config('password', '')
        else:
            # basic (plain-text) settings
            username = settings.value('username', '', type=str)
            password = settings.value('password', '', type=str)
        return username, password

    def pbParameterShowClicked(self):

        sd = self.dockwidget
        uri = self.conuri

        schema = ''
        table = ''
        geom = ''        
        if sd.leParameterTable.text().find('.') >= 0:
            sandt = sd.leParameterTable.text().split('.',1)
            schema = sandt[0]
            table = sandt[1]
        else:
            table = sd.leParameterTable.text()
        uri.setDataSource(schema, table, '','','name')
        uri.setUseEstimatedMetadata(True)
        self.parameterLayer = QgsVectorLayer(uri.uri(), "parameters", self.contype)
        if self.parameterLayer: addLayer2Tree(QgsProject.instance().layerTreeRoot(), self.parameterLayer, False, 'eco_layername', sd.leParameterTable.text(), os.path.join(self.plugin_dir, 'styles', 'parameters.qml'),'Parameters')

    def cbDatabaseCurrentIndexChanged(self, index):
    
        sd = self.dockwidget

        if sd.cbDatabase.currentIndex() >= 0:
            setting = sd.cbDatabase.itemData(sd.cbDatabase.currentIndex())
            metadata = QgsProviderRegistry.instance().providerMetadata(setting[0])
            self.connection = metadata.findConnection(setting[1])
            
    

    def pbParameterResetClicked(self):

        sd = self.dockwidget
        spd = self.parm["Data"]

        spd["Parametertable"] =  sd.leParameterTable.text() 
        spd["Database"] =  sd.cbDatabase.currentText() 
        write_config(os.path.join(self.plugin_dir, 'configuration.json'), self.parm)

        if sd.cbDatabase.currentIndex() >= 0:

            setting = sd.cbDatabase.itemData(sd.cbDatabase.currentIndex())
            metadata = QgsProviderRegistry.instance().providerMetadata(setting[0])
            self.connection = metadata.findConnection(setting[1])
            uri = QgsDataSourceUri(self.connection.uri())


            self.conuri = self.dbConnection2Db (setting[0], setting[1])
            self.contype = setting[0]

            self.parmDict, hl = self.createParmDict(spd["Parametertable"], spd["Parameterkeyfield"], spd["Parameterkeyvalue"], spd["Parametervaluefield"])        
            if hl:
                sd.leGroupName.setText(self.parmDict['Group name template']['value'])
                (modG, modD, modQ, modM, modR) = self.createTreeModels (QStandardItemModel(), QStandardItemModel(), QStandardItemModel(), QStandardItemModel(), QStandardItemModel(), self.parmDict, 'name', 'parent', 'checkable', 'explanation', hl)
            
                sd.tvGeneral.setModel(modG)
                sd.tvData.setModel(modD)
                sd.tvQueries.setModel(modQ)
                sd.tvModels.setModel(modM)
                #sd.tvReports.setModel(modR)
    
                for tv in [sd.tvGeneral, sd.tvData, sd.tvQueries, sd.tvModels]: #, sd.tvReports]:
                    for i in range(modG.columnCount()): tv.hideColumn(i)
                    for i in [0,2]: tv.showColumn(i)
                    tv.header().setStretchLastSection(True);
                    tv.header().setSectionResizeMode(QHeaderView.ResizeToContents)
                    tv.setAlternatingRowColors(True)        
                    tv.setUniformRowHeights(True)
                    
                sd.tvGeneral.expandAll()
                sd.tvData.expandAll()
                sd.tvQueries.expandAll()
                sd.tvModels.expandAll()
                #sd.tvReports.expandAll()
                self.loadHistTree(sd.tvHistory, self.connection,'')
                celllayer = self.parmDict['Cell layername']['value']
                sd.leLayerName.setText(celllayer)
                
                cellsize = float(self.parmDict['Cell size']['value'])
                sd.dsbCellSize.setValue(cellsize)
                
                self.pbMapperExtentsClicked()
                self.pbUpdateLayerTreeClicked()
            else:
                messC(self.tr('Error accessing parameter table'))
        else:
            messC(self.tr('Database connection and/or parametertable not set'))
            
    def pbModelRunClicked(self):

        sd = self.dockwidget

        #mDict = self.createTempParmDict([[sd.tvGeneral.model().invisibleRootItem().child(0,0), True], [sd.tvQueries.model().invisibleRootItem().child(0,0), True], [sd.tvData.model().invisibleRootItem().child(0,0), True], [sd.tvModels.model().invisibleRootItem().child(0,0), True]])

        mDict = {}
        nDict = {}
      
        for root in [sd.tvGeneral.model().invisibleRootItem().child(0,0),sd.tvQueries.model().invisibleRootItem().child(0,0),sd.tvData.model().invisibleRootItem().child(0,0),sd.tvModels.model().invisibleRootItem().child(0,0)]:
            for item in self.iterItemsChecked(root, True):
                parent = item.parent()
                key = parent.child(item.row(),0).text()
                if parent.child(item.row(),3).text() == 'Q': # Key is an alias
                    alias = parent.child(item.row(),6).text()
                    #logI('alias='+alias)                    
                    for k in mDict:
                        #logI('key={}, value={}'.format(k,mDict[k]))                    
                        if k.endswith(alias): 
                            nDict[k.replace(alias,'')+key] = mDict[k] 
                            #logI('***key={}, value={}'.format(k.replace(alias,'')+key,nDict[k.replace(alias,'')+key]))                    
                else:
                    value = parent.child(item.row(),2).text()
                    mDict[key] = value

        for k,v in nDict.items(): mDict[k] = v

        # Create results layergroup
        rGroup = createGroup(mDict['Model_layergroup'], QgsProject.instance().layerTreeRoot(), True)
        time_stamp=QDateTime.currentDateTime().toString(Qt.ISODate)
        rDtnGroup = createGroup(sd.leGroupName.text().format(time_stamp=time_stamp), rGroup, False)
        query = executeSQL('INSERT INTO fdc_results.batches (name, run_at, no_models) VALUES (\'{name}\', \'{time_stamp}\', 0) RETURNING bid;'.format(name=rDtnGroup.name(), time_stamp=time_stamp))
        if query:
            while query.next(): 
                bid = query.value(0)

        # run choosen models
        no_models = 0
        for item in self.iterItemsChecked(sd.tvModels.model().invisibleRootItem().child(0,0)):

            tic = time.perf_counter() 
            qname, vlayer, no_rows, keylist, tablename = self.runModel(item, mDict)
            toc = time.perf_counter()
            no_secs = toc - tic

            if no_rows > 0:
                query = executeSQL('INSERT INTO fdc_results.used_models ( bid, table_name, name, no_rows, no_secs) VALUES ({bid},\'{table}\',\'{name}\', {no_rows}, {no_secs}) RETURNING mid;'.format(bid=bid, no_rows=no_rows, no_secs=no_secs, table=tablename, name=item.text()))
                if query:
                    while query.next(): 
                        mid = query.value(0)
    
                for k,v in keylist.items(): 
                    if k[0:2] != 'f_' and k[0:2] != 't_': query = executeSQL('INSERT INTO fdc_results.used_parameters (mid, name, value) VALUES ({mid},\'{name}\',\'{value}\');'.format(mid=mid, name=k, value=v))
    
                if  vlayer: 
                    addLayer2Tree(rDtnGroup, vlayer, False, 'eco_resultlayer', qname, os.path.join(self.plugin_dir, 'styles', item.text() + '.qml'), item.text())
    
                no_models += 1


        query = executeSQL('UPDATE fdc_results.batches SET no_models = {no_models} WHERE bid = {bid};'.format(no_models=no_models, bid = bid))

        self.pbUpdateLayerTreeClicked()
        self.pbHistResetSearchClicked()
     
    def runModel (self, item, lDict):
    
        sd = self.dockwidget
        
        # First create query instance.
        query = QSqlQuery()
        
        # Find query name
        parent = item.parent()
        lTxt = parent.child(item.row(),7).text() # From column "default"
        nTxt = parent.child(item.row(),0).text() # From column "name"
        # Create new tablename for result datasaet using model name and timestamp
        lDict['tablename_ts'] = createDateTimeName(item.text())
        # Create artificial query entry in lDict using actual query entry        
        lDict['sqlquery'] = lDict[lTxt].format(**lDict)

        # Set return values ao to default
        cnt = 0
        kl = {}
        pattern = '\{[\w ,;]+\}'

        # Create create table... command
        qct = lDict['Create_result_table'].format(**lDict)
        
        # Create table by executing command
        query = executeSQL(qct, showerror=False)

        # Check if query generated a table
        if query:

            query = executeSQL('SELECT COUNT(*) FROM "{}"."{}"'.format(lDict['Result_schema'],lDict['tablename_ts']))
            if query:
                while query.next(): 
                    cnt = query.value(0)
    
            if 'f_geom_'+ lTxt in lDict:
    
                # Create artificial geom_column entry in lDict using actual query name        
                lDict['geom_column'] = lDict['f_geom_' + lTxt] 
                geom_col = lDict['geom_column']
        
                # Create spatial index... command
                qct = lDict['Create_result_index'].format(**lDict)
                # Create spatial index by executing command
                query = executeSQL(qct) 
            else:
                geom_col = ''
            
    
            if 'f_pkey_'+ lTxt in lDict:
                # Create artificial pkey_column entry in lDict using actual query name        
    
                lDict['pkey_column'] = lDict['f_pkey_'+ lTxt]
                pkey_col = lDict['pkey_column']
        
                # Create primary key... command
                qct = lDict['Create_result_pkey'].format(**lDict)
        
                # Create primary key by executing command
    #            query.exec(qct) 
                query = executeSQL(qct) 
            else:
                pkey_col = ''

            # Create keylist
            kl['SQL expression'] = lDict['sqlquery'].replace("'","''")
            kl[lTxt] = lDict[lTxt].replace("'","''")
            ldlt =   lDict[lTxt]  
            for match in re.finditer(pattern,ldlt): 
                k = ldlt[match.start()+1:match.end()-1]
                kl[k] = lDict[k]
            

            # Create layer with new table and add it to mapper
            contype = self.contype
            uri = self.conuri
            uri.setDataSource(lDict['Result_schema'], lDict['tablename_ts'], geom_col , '', pkey_col)
            vlayer=QgsVectorLayer (uri.uri(), nTxt, contype)

            return lTxt, vlayer, cnt, kl, lDict['tablename_ts']

        else:
            messI(self.tr('Execution of model: "{}" did not yield any results').format(nTxt))
            return lTxt, None, cnt, kl, lDict['tablename_ts']

        
#    def createTempParmDict (self, roots):
#
#        tDict = {}    
#        for r in roots:
#            r0 = r[0]
#            r1 = r[1]            
#            for row in range(r0.rowCount()):
#                key   = r0.child(row, 0).text()
#                value = r0.child(row, 2).text()
#                tDict[key] = value
#                item = r0.child(row, 0)
#                if r1 and item.hasChildren():
#                    for rowi in range(item.rowCount()):
#                        key   = item.child(rowi, 0).text()
#                        value = item.child(rowi, 2).text()
#                        tDict[key] = value
#
#        return tDict

    def iterItemsChecked(self, root, dontCheck=False):
        if root is not None:
            stack = [root]
            while stack:
                parent = stack.pop(0)
                for row in range(parent.rowCount()):
                    child = parent.child(row, 0)
                    if child.checkState() == Qt.Checked or dontCheck : yield child
                    if child.hasChildren(): stack.append(child)

    def iterItemsMatch(self, root, match=None):
        if root is not None:
            stack = [root]
            while stack:
                parent = stack.pop(0)
                for row in range(parent.rowCount()):
                    child = parent.child(row, 0)
                    if match is None or match == child.text(): yield child
                    if child.hasChildren(): stack.append(child)

    def treeViewItemText(self, tv, match, column):
         
        root = tv.model().invisibleRootItem()
        for item in self.iterItemsMatch(root, match):
            parent = item.parent()
            return parent.child(item.row(),column).text()
        
        messC(self.tr('Can''t find item: "{}" in tree: "{}"').format(match,tv.objectName()),'treeViewItemText')
        return None
        
        
    def iterRowCheckable(self, root, dontCheck=False):
        if root is not None:
            stack = [root]
            while stack:
                parent = stack.pop(0)
                for row in range(parent.rowCount()):
                    rowval = []
                    for column in range(parent.columnCount()): rowval.append(parent.child(row, column))
                    if dontCheck == True or dontCheck == False and rowval[0].isCheckable(): yield rowval
                    child0 = parent.child(row, 0)
                    if child0.hasChildren(): stack.append(child0)


    def createParmDict(self, ptable, pkfield, pkvalue, pvfield):

        txt = 'SELECT "{0}" FROM {1} WHERE "{2}"=\'{3}\''.format( pvfield, ptable, pkfield, pkvalue)
        query = executeSQL(txt) 
         
        if query:
            while query.next(): txt = query.value(0)
            txt = txt.format(parametertable=ptable)

            query = executeSQL(txt) 
            if query:
                #logI('createparmDict, sql udført')
                pdict = {}    
                while query.next():
                    ldict = {}
                    rec = query.record()
                    for i in range(rec.count()-1): 
                        #logI('createparmDict, value ' + str(rec.fieldName(i)) + ' = ' + str(query.value(i)))
                        ldict[rec.fieldName(i)] = query.value(i)
                    pdict[query.value(pkfield)] = ldict
        
                return pdict, [rec.fieldName(i) for i in range(rec.count()-1)]
        
        return None, None

    def loadHistTree(self, tv, connection, filter):

        model = QStandardItemModel()
        model.setHorizontalHeaderLabels(['Name', 'Value'])
        tv.header().setDefaultSectionSize(90)
        tv.header().setStretchLastSection(True);
        tv.header().setSectionResizeMode(QHeaderView.ResizeToContents)
        tv.setAlternatingRowColors(True)        
        tv.setUniformRowHeights(True)
        tv.setModel(self.importHistModel(connection, model, filter))
        tv.setEditTriggers(QAbstractItemView.NoEditTriggers)     

    def importHistModel(self, connection, model, filter=''):

        model.setRowCount(0)
        root = model.invisibleRootItem()

        if filter != '': 
            txtWhere = ' WHERE {filter} '.format(filter=filter)
        else: 		
            txtWhere = ' '

        txtSql_b = 'SELECT bid, batch_name, no_models, run_at::varchar FROM fdc_results.used_parameters_view' + txtWhere + ' GROUP BY bid, batch_name, run_at, no_models ORDER BY bid'
        txtSql_m = 'SELECT bid, mid, model_name, no_rows, no_secs::NUMERIC(6,2) FROM fdc_results.used_parameters_view' + txtWhere + ' GROUP BY bid, mid, model_name, no_rows, no_secs ORDER BY bid, mid'
        txtSql_p = 'SELECT mid, uid, parameter_name, value FROM fdc_results.used_parameters_view' + txtWhere + ' GROUP BY bid, mid, uid, parameter_name, value ORDER BY mid, uid'

        table_b = connection.executeSql(txtSql_b)

        seen_b = {}
        for row_b in table_b:
            unique_id = row_b[0]
            root.appendRow([
                QStandardItem(str(row_b[1])),
                QStandardItem('{} {}, {} {}.'.format(row_b[2], self.tr(' models'), self.tr(' run at '), row_b[3]))
            ])
            seen_b[unique_id] = root.child(root.rowCount() - 1)

        table_m = connection.executeSql(txtSql_m)

        seen_m = {}
        for row_m in table_m:
            unique_id = row_m[1]
            parent = seen_b[row_m[0]]
            parent.appendRow([
                QStandardItem(str(row_m[2])),
                QStandardItem('{} {}, {} {}.'.format(row_m[3], self.tr(' rows'), row_m[4], self.tr(' seconds')))
            ])
            seen_m[unique_id] = parent.child(parent.rowCount() - 1)

        table_p = connection.executeSql(txtSql_p)

        for row_p in table_p:
            parent = seen_m[row_p[0]]
            parent.appendRow([
                QStandardItem(str(row_p[2])),
                QStandardItem(str(row_p[3])),
            ])
        
        return model




        
    def createTreeModels (self, modG, modD, modQ, modM, modR, pDict, fieldN, fieldP, fieldC, fieldE, hl):

        #QStandardItemModel()
        modG.setRowCount(0)
        modD.setRowCount(0)
        modQ.setRowCount(0)
        modM.setRowCount(0)
        modR.setRowCount(0)

        modG.setHorizontalHeaderLabels(hl)
        modD.setHorizontalHeaderLabels(hl)
        modQ.setHorizontalHeaderLabels(hl)
        modM.setHorizontalHeaderLabels(hl)
        modR.setHorizontalHeaderLabels(hl)
        
        rootG = modG.invisibleRootItem()
        rootD = modD.invisibleRootItem()
        rootQ = modQ.invisibleRootItem()
        rootM = modM.invisibleRootItem()
        rootR = modR.invisibleRootItem()


        for k, v in pDict.items():

            if str(v[fieldP]) == '':
                if   v[fieldN] == 'General': parent = rootG
                elif v[fieldN] == 'Data':    parent = rootD
                elif v[fieldN] == 'Queries': parent = rootQ
                elif v[fieldN] == 'Models':  parent = rootM
                elif v[fieldN] == 'Reports': parent = rootR

            else:
                parent = pDict[v[fieldP]]['_Id_']            

            row = []
            cable = False
            for key, val in v.items():
                qsi = QStandardItem('' if str(val)=='NULL' else str(val))
                if key==fieldN:
                    if v[fieldC].upper() in ('T','Y','J','C'):
                        qsi.setFlags(qsi.flags() | Qt.ItemIsUserCheckable)
                        qsi.setCheckState(Qt.Unchecked)
                        cable = True
                    if v[fieldE] != 'NULL' or v[fieldE] != '': qsi.setToolTip(str(v[fieldE]))
                row.append(qsi) 
                
            parent.appendRow(row)
            if cable: parent.setFlags(parent.flags() | Qt.ItemIsTristate | Qt.ItemIsUserCheckable)
            pDict[k]['_Id_'] = parent.child(parent.rowCount() - 1)

        return (modG, modD, modQ, modM, modR)

    def tvGeneralDoubleClicked(self, index):
        self.tvAllDoubleClicked(self.dockwidget.tvGeneral, index)

    def tvQueriesDoubleClicked(self, index):
        self.tvAllDoubleClicked(self.dockwidget.tvQueries, index)

    def tvDataDoubleClicked(self, index):
        self.tvAllDoubleClicked(self.dockwidget.tvData, index)

    def tvModelsDoubleClicked(self, index):
        self.tvAllDoubleClicked(self.dockwidget.tvModels, index)

    #def tvReportsDoubleClicked(self, index):
    #    self.tvAllDoubleClicked(self.dockwidget.tvReports, index)

    def tvAllDoubleClicked(self, tree, index):
    
        sd = self.dockwidget
        spd = self.parm["Data"]
        parent = index.parent()
        row = index.row()
        val = []

        for col in range(PARM_NO_COLUMNS - 1):
            it = parent.child(row, col)
            val.append(str(it.data()))
        # Horrible kludge to get value from parent for "Field selector" type
        if val[3].lower() == 'f': val.append(str(parent.parent().child(parent.row(),2).data()))
        rect = tree.visualRect(parent.child(row, 0))
        pos = tree.viewport().mapToGlobal(rect.topLeft())
        width = int(sd.width()*0.8)
        
        result, newval, newval2 =  self.treeViewEditItem(pos, width, val)
        
        if result and newval:
            it = parent.child(row, 2)
            it.model().setData(it, newval)

        if result and newval2:
            it = parent.child(row, 6)
            it.model().setData(it, newval2)

    def pbCSVExportDirClicked (self):

        sd = self.dockwidget
        run_dir = sd.leCSVExportDir.text()
        new_dir = QFileDialog.getExistingDirectory(None, self.tr("Select directory for CSV files"), run_dir, QFileDialog.ShowDirsOnly)
        if new_dir: 
            sd.leCSVExportDir.setText(new_dir)

    def pbCSVExportClicked (self):

        sd = self.dockwidget
        result_path = sd.leCSVExportDir.text()
        group_name = self.treeViewItemText(sd.tvGeneral,'Model_layergroup',2)
        merge_layers_in_group(group_name, result_path)

    def treeViewEditItem(self, pos, width, val):

        sd = self.dockwidget
        spdid = self.parm["Data"]["Item delimiter"]

        dlg = QDialog()
        dlg.setWindowTitle('Set value for "{}"->"{}"'.format(val[1],val[0]))

        func = val[3].strip().upper()

        if func in ['T','P','R','I','O','M','X','D','E','B','S','F','Q']:

            layout = QVBoxLayout()

            if func=='T': # Single line

                input = QLineEdit()
                input.setText(val[2])

            elif func=='P': # Multiple line           

                input = QTextEdit()
                input.setText(val[2])

            elif func=='R': # Real value

                input = QDoubleSpinBox()
                input.setMinimum(float(val[4]))
                input.setMaximum(float(val[5]))
                input.setSingleStep(float(val[6]))
                input.setValue(float(val[2]))

            elif func=='I': # Integer value

                input = QSpinBox()
                input.setMinimum(int(val[4]))
                input.setMaximum(int(val[5]))
                input.setSingleStep(int(val[6]))
                input.setValue(int(val[2]))

            elif func=='O': # Single select

                input = QComboBox()
                input.clear()
                input.addItems(val[6].split(spdid))
                input.setCurrentIndex(input.findText(val[2]))
                
            elif func=='M': # Multiple select

                input = QgsCheckableComboBox()
                input.clear()
                input.setSeparator(spdid)
                input.addItems(val[6].split(spdid))
                input.setCheckedItems(val[2].split(spdid))
                #input.checkedItems()-- liste med checked items
                
            elif func=='X': # Datetime

                input = QDateTimeEdit()
                input.setDateTime(QDateTime.fromString(val[2],"yyyy-MM-dd HH:mm:ss"))
                input.setCalendarPopup(True)

                
            elif func=='D': # Date

                input = QDateEdit()
                input.setDate(QDate.fromString(val[2],"yyyy-MM-dd"))
                input.setCalendarPopup(True)
                
            elif func=='E': # Time

                input = QTimeEdit()
                input.setTime(QTime.fromString(val[2],"HH:mm:ss"))

            elif func=='B': # Boolean
                input= QCheckBox(val[6])
                input.setChecked(val[2].upper()=='TRUE')

            elif func=='S': # Schema/table selector

                if sd.cbDatabase.currentIndex() >= 0:
                    setting = sd.cbDatabase.itemData(sd.cbDatabase.currentIndex())
                    metadata = QgsProviderRegistry.instance().providerMetadata(setting[0])
                    connection = metadata.findConnection(setting[1])
                    input = DBTableSelector(connection)
                    input.setFullName(val[2])

            elif func=='F': # Field selector

                if sd.cbDatabase.currentIndex() >= 0:
                    setting = sd.cbDatabase.itemData(sd.cbDatabase.currentIndex())
                    metadata = QgsProviderRegistry.instance().providerMetadata(setting[0])
                    connection = metadata.findConnection(setting[1])
                    input = DBFieldSelector(connection)
                    input.setFieldName(val[len(val)-1],val[2])

            elif func=='Q': # Tab tree selector

                input = TreeItemSelector(sd.tvData)
                input.setFullName(val[2],'S',val[7])
                
            layout.addWidget(input,5)

            buttonBox = QDialogButtonBox()
            buttonBox.setStandardButtons(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
            buttonBox.rejected.connect(dlg.reject)
            buttonBox.accepted.connect(dlg.accept)
            layout.addWidget(buttonBox)

            #layout.setSizeConstraint(QLayout.SetFixedSize)
            dlg.setLayout(layout)
            dlg.setWindowFlags(dlg.windowFlags() & ~QtCore.Qt.WindowCloseButtonHint)
            input.setMinimumWidth(width)
            dlg.move(pos)
            dlg.setSizeGripEnabled(True)
            res = dlg.exec()
            
            value2 = None
            
            if res:

                if func=='T': # Single line
    
                    value = input.text()
    
                elif func=='P': # Multiple line           
    
                    value = input.toPlainText()
    
                elif func=='R': # Real value
    
                    value = str(input.value())
    
                elif func=='I': # Integer value
    
                    value = str(input.value())
    
                elif func=='O': # Single select
    
                    value = str(input.currentText())
                    
                elif func=='M': # Multiple select
    
                    value = spdid.join(input.checkedItems())
                    
                elif func=='X': # Datetime
    
                    value = input.dateTime().toString("yyyy-MM-dd HH:mm:ss")
                    
                elif func=='D': # Date
    
                    value = input.date().toString("yyyy-MM-dd")
                    
                elif func=='E': # Time
    
                    value = input.time().toString("HH:mm:ss")
    
                elif func=='B': # Boolean

                    value = 'True' if input.isChecked() else 'False'

                elif func=='S': # Schema / Table selector

                    value = input.getFullName()

                elif func=='F': # Field selector

                    value = input.getFieldName()

                elif func=='Q': # Tree selector

                    value, value2 = input.getFullName()
                
            else:
                value = None
                
            return res, value, value2
            
        return None, None

class DBTableSelector(QWidget):
    """
    TBD
    """

    def __init__(self, connection, schemaPrefix='Schema Name: ', tablePrefix='Table Name: '):

        super(DBTableSelector, self).__init__()

        self.connection = connection
        self.sName= None
        self.tName= None

        layout = QVBoxLayout()
        
        if (self.connection.capabilities() & QgsAbstractDatabaseProviderConnection.Schemas):

            self.schemaLabel = QLabel()
            self.schemaLabel.setText(schemaPrefix)
            self.schemaNames = QComboBox()
            for s in self.connection.schemas(): self.schemaNames.addItem(s)
            self.schemaNames.currentIndexChanged.connect (self.schemaNamesCurrentIndexChanged)

            hlayout = QHBoxLayout()
            hlayout.addWidget(self.schemaLabel,0)
            hlayout.addWidget(self.schemaNames,5)
            layout.addLayout(hlayout)

        else:
           self.schemaNames = None

        self.tableLabel = QLabel()
        self.tableLabel.setText(tablePrefix)
        self.tableNames = QComboBox()
        self.tableNames.currentIndexChanged.connect (self.tableNamesCurrentIndexChanged)

        hlayout = QHBoxLayout()
        hlayout.addWidget(self.tableLabel,0)
        hlayout.addWidget(self.tableNames,5)
        layout.addLayout(hlayout)

        self.setLayout(layout)

    def schemaNamesCurrentIndexChanged(self, index):

        if self.schemaNames is not None: self.sName = self.schemaNames.currentText() 
        self.setTableNames(self.sName, self.tName)

    def setTableNames(self, schema, table):

        tables = self.connection.tables(schema, QgsAbstractDatabaseProviderConnection.Aspatial | QgsAbstractDatabaseProviderConnection.Vector)

        self.tableNames.clear()
        for t in tables: self.tableNames.addItem(t.tableName())
        
        self.tableNames.setCurrentIndex(self.tableNames.findText(table))                

    def tableNamesCurrentIndexChanged(self, index):
        self.tName = self.tableNames.currentText() 
    
    def getFullName(self):
        if self.sName is not None:
            return '"{}"."{}"'.format(self.sName,self.tName)
        else:
            return '"{}"'.format(self.tName)
    
    def setFullName(self,fullName=''):

        if fullName != '':

            names = fullName.replace('"','').split('.')

            if len(names) == 2:
                self.sName = names[0]        
                self.tName = names[1] 

            else:            
                self.tName = names[0]        

        if self.sName is not None: self.schemaNames.setCurrentIndex(self.schemaNames.findText(self.sName))                
        self.setTableNames(self.sName, self.tName)

class DBFieldSelector(QWidget):

    """
    TBD
    """

    def __init__(self, connection, fieldPrefix='Fieldname: '):

        super(DBFieldSelector, self).__init__()

        self.connection = connection

        self.fieldLabel = QLabel()
        self.fieldLabel.setText(fieldPrefix)
        self.fieldNames = QComboBox()
        self.fieldNames.currentIndexChanged.connect (self.fieldNamesCurrentIndexChanged)

        layout = QHBoxLayout()
        layout.addWidget(self.fieldLabel,0)
        layout.addWidget(self.fieldNames,5)
        self.setLayout(layout)


    def fieldNamesCurrentIndexChanged(self, index):
        self.fName = self.fieldNames.currentText() 
    
    def getFieldName(self):
        return '"{}"'.format(self.fName)
    
    def setFieldName(self, fullName='', fieldName=''):

        fieldName = fieldName.replace('"','')
        
        if fullName != '':

            names = fullName.replace('"','').split('.')

            if len(names) == 2:
                self.sName = names[0]        
                self.tName = names[1] 

            else:            
                self.tName = names[0]        

        self.fieldNames.clear()

        if self.connection.tableExists (self.sName, self.tName):
 
            fields = self.connection.fields(self.sName, self.tName)
            for f in fields: self.fieldNames.addItem(f.name())

        self.fieldNames.setCurrentIndex(self.fieldNames.findText(fieldName))                
        self.fName = self.fieldNames.currentText()
        
class TreeItemSelector(QWidget):

    """
    TBD
    """

    def __init__(self, tree, treePrefix='Tablename: '):

        super(TreeItemSelector, self).__init__()

        self.tree = tree
        self.fName = None
        self.fVal = None
        
        self.treeLabel = QLabel()
        self.treeLabel.setText(treePrefix)
        self.treeNames = QComboBox()
        self.treeNames.currentIndexChanged.connect (self.treeNamesCurrentIndexChanged)

        layout = QHBoxLayout()
        layout.addWidget(self.treeLabel,0)
        layout.addWidget(self.treeNames,5)
        self.setLayout(layout)

    def treeNamesCurrentIndexChanged(self, index):
        self.fName = self.treeNames.currentText() 
        self.fVal = self.treeNames.currentData() 
    
    def getFullName(self):
        
        return self.fName, self.fVal
    
    def iterRowItems(self, root):
        if root is not None:
            stack = [root]
            while stack:
                parent = stack.pop(0)
                for row in range(parent.rowCount()):
                    rowval = []
                    for column in range(parent.columnCount()): rowval.append(parent.child(row, column).text())
                    yield rowval
                    child0 = parent.child(row, 0)
                    if child0.hasChildren(): stack.append(child0)

    def setFullName(self, fullName, treeType='', treeSearch=''):

        self.treeNames.clear()

        root = self.tree.model().invisibleRootItem()

        for row in self.iterRowItems(root): 
            name  = row[0]
            value = row[2]
            type  = row[3]
            if name.startswith(treeSearch) and type == treeType and self.treeNames.findText(value) == -1: self.treeNames.addItem(value, name)

#        root = self.tree.model().invisibleRootItem().child(0,0)

#        for row in range(root.rowCount()):
#            name  = root.child(row,0).text()
#            value = root.child(row,2).text()
#            type  = root.child(row,3).text()
#            if name.startswith(treeSearch) and type == treeType: self.treeNames.addItem(value, name)

        self.treeNames.setCurrentIndex(self.treeNames.findText(fullName))     

